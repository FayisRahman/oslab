//create-1 and delete-4 syscall
alias userSP R0;
userSP = SP;
[PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 13] = SP;

SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 11] * 512 - 1;

alias syscallNum R1;
syscallNum = [([PTBR + 2 * ((userSP-5)/512)] * 512 + ((userSP-5)%512))];

alias returnAddress R2;
returnAddress = ([PTBR + 2 * ((userSP-1)/512)] * 512 + ((userSP-1)%512));

alias fileName R3;
fileName = [([PTBR + 2 * ((userSP-4)/512)] * 512 + ((userSP-4)%512))];

alias permission R4;
permission = [([PTBR + 2 * ((userSP-3)/512)] * 512 + ((userSP-3)%512))];

alias i R5;

//create
if(syscallNum == 1) then

    [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 1; //create syscall

    //checking if a file exists with the filename
    
    i = 0;
    while(i<MAX_FILE_NUM) do
        if([INODE_TABLE + i * 16 + 1] == fileName) then
            break;
        endif;
        i = i + 1;
    endwhile;

    if(i != MAX_FILE_NUM) then //file present in the disk
        [returnAddress] = 0;
    else
        //no file with filename so now we find a free slot to add the file
        i = 0;
        while(i<MAX_FILE_NUM) do
            if([INODE_TABLE + i * 16 + 1] == -1) then //checking filename entry
                break;
            endif;
            i = i + 1;
        endwhile;

        if(i == MAX_FILE_NUM) then //no free space
            [returnAddress] = -1;
        else
            //setting the inode table
            [INODE_TABLE + i * 16 + 0] = DATA; //file type
            [INODE_TABLE + i * 16 + 1] = fileName;
            [INODE_TABLE + i * 16 + 2] = 0; //file size
            [INODE_TABLE + i * 16 + 3] = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 3]; //USERID
            [INODE_TABLE + i * 16 + 4] = permission;

            //setting the Root table
            [ROOT_FILE + i * 8 + 0] = [INODE_TABLE + i * 16 + 1]; //fileName
            [ROOT_FILE + i * 8 + 1] = [INODE_TABLE + i * 16 + 2]; //file size
            [ROOT_FILE + i * 8 + 2] = [INODE_TABLE + i * 16 + 0]; //file type
            [ROOT_FILE + i * 8 + 3] = [INODE_TABLE + i * 16 + 3]; //USERID
            [ROOT_FILE+ i * 8 + 4] = [INODE_TABLE + i * 16 + 4]; //permission
            
        endif;
    endif;

    SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 13];
    [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
    ireturn;

endif;

//delete
if(syscallNum == 4) then

    [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 4; //create syscall

    //checking if a file exists with the filename
    i = 0;
    while(i<MAX_FILE_NUM) do
        if([INODE_TABLE + i * 16 + 1] == fileName) then
            break;
        endif;
        i = i + 1;
    endwhile;

    if(i == MAX_FILE_NUM) then //file not present in the disk
        print "file no exist";
        [returnAddress] = 0;
    else 
        if([INODE_TABLE + i * 16 + 0] != DATA) then //file present is not DATA file type
            [returnAddress] = -1;    
        else 
            if( [INODE_TABLE + i * 16 + 4] == 0 && [INODE_TABLE + i * 16 + 3] != [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 3] ) then //exclusive permission is set and userID is same as the userID in the inode entry
                [returnAddress] = -1;
            else
                //now we start deleting
                //for that we need to accquire the inode lock

                multipush(R1,R2,R3,R4,R5);
                R1 = 4; //accquiring inode
                R2 = i; //inode entry
                R3 = [SYSTEM_STATUS_TABLE + 1]; //pid
                call RESOURCE_MANAGER;
                multipop(R1,R2,R3,R4,R5);

                if( [FILE_STATUS_TABLE + i * 4 + 1] != -1 ) then //file is open
                    multipush(R1,R2,R3,R4,R5);
                    R1 = 5; //releasing inode
                    R2 = i; //inode entry
                    R3 = [SYSTEM_STATUS_TABLE + 1]; //pid
                    call RESOURCE_MANAGER;
                    multipop(R1,R2,R3,R4,R5);

                    [returnAddress] = -2;
                    
                else

                    //file is not open
                    alias blkNum R6;
                    blkNum = INODE_TABLE + i*16 + 8;
                    alias bufferIdx R7;
                    multipush(R5);
                    i = blkNum + 4;//max 4 blocks
                    while(blkNum < i) do
                        if ([blkNum] == -1) then
                            break;
                        endif;
                        //checking the dirty bit
                        bufferIdx = [blkNum] % MAX_BUFFER;

                        if([BUFFER_TABLE + bufferIdx * 4 + 0] == [blkNum] && [BUFFER_TABLE + bufferIdx * 4 + 1] == 1) then // checking if dirt birt is set
                            [BUFFER_TABLE + bufferIdx * 4 + 1] = 0;
                        endif ;
                        
                        //release block
                        multipush(R1,R2,R3,R4,R5,R6);
                        R1 = 4; //releasing block
                        R2 = [blkNum]; // blkNum
                        R3 = [SYSTEM_STATUS_TABLE + 1]; //pid
                        call MEMORY_MANAGER;
                        multipop(R1,R2,R3,R4,R5,R6);

                        blkNum = blkNum + 1;

                    endwhile;
                    multipop(R5); //reason why i did this was to get the value of "i" back as here i holds the value of the index of the inode of the dat file 
                    //invalidating inodePages
                    alias inodePages R8;
                    inodePages = INODE_TABLE + i*16;

                    alias limit R9;
                    limit = inodePages + 16;

                    while (inodePages < limit) do
                        [inodePages] = -1;
                        inodePages = inodePages + 1;
                    endwhile;

                    //invalidating root entry
                    alias rootFile R10;
                    rootFile = ROOT_FILE + 8 * i;
                    limit = rootFile + 8;
                    while (rootFile < limit) do
                        [rootFile] = -1;
                        rootFile = rootFile + 1;
                    endwhile;
                    
                    //release inode lock
                    multipush(R2);
                    R1 = 5; //releasing inode lock
                    R2 = i; // blkNum
                    R3 = [SYSTEM_STATUS_TABLE + 1]; //pid
                    call RESOURCE_MANAGER;
                    multipop(R2);

                    [returnAddress] = 0;
                endif;
            endif;
        endif;
    endif;
    SP = [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 13];
    [PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1] * 16 + 9] = 0;
    ireturn;

endif;


